#!/usr/bin/env tsx
/**
 * Spec-driven scaffolder.
 * Reads docs/spec.md and docs/project-rules.md to generate/refresh
 * placeholder code, JSON Schemas, and contract types without business logic.
 */

import { promises as fs } from 'fs'
import path from 'path'

const ROOT_DIR = path.resolve(__dirname, '..')
const SPEC_PATH = path.join(ROOT_DIR, 'docs/spec.md')
const PROJECT_RULES_PATH = path.join(ROOT_DIR, 'docs/project-rules.md')
const GENERATED_TAG = 'GENERATED BY scripts/scaffold.ts'

interface ScopeEntry {
  path: string
  description: string
}

interface SchemaEntry {
  schemaPath: string
  schemaJson: any
}

interface BackendModelEntry {
  moduleName: string
  className: string
  filePath: string
}

type JsonSchema = {
  title?: string
  type?: string
  properties?: Record<string, JsonSchema>
  required?: string[]
  enum?: Array<string | number | boolean>
  items?: JsonSchema
  description?: string
  format?: string
  additionalProperties?: boolean | JsonSchema
}

async function readFileSafe(filePath: string): Promise<string> {
  try {
    return await fs.readFile(filePath, 'utf-8')
  } catch (error: any) {
    if (error && error.code === 'ENOENT') {
      return ''
    }
    throw error
  }
}

function extractScopeEntries(specContent: string): ScopeEntry[] {
  const lines = specContent.split(/\r?\n/)
  const entries: ScopeEntry[] = []
  let inScope = false
  for (const rawLine of lines) {
    const line = rawLine.trim()
    if (!inScope) {
      if (line === 'Scope:') {
        inScope = true
      }
      continue
    }

    if (line.length === 0) {
      break
    }

    if (!line.startsWith('-')) {
      continue
    }

    const afterDash = line.slice(1).trim()
    const [pathPart, ...descParts] = afterDash.split(':')
    if (!pathPart || descParts.length === 0) {
      continue
    }

    const entryPath = pathPart.trim()
    const description = descParts.join(':').trim()
    if (!entryPath || !description) {
      continue
    }

    entries.push({ path: entryPath, description })
  }
  return entries
}

function extractSchemaEntries(specContent: string): SchemaEntry[] {
  const schemaEntries: SchemaEntry[] = []
  const schemaBlockRegex = /-\s+(schemas\/[\w\-]+\.schema\.json)\s*\n```json\n([\s\S]*?)\n```/g
  let match: RegExpExecArray | null
  while ((match = schemaBlockRegex.exec(specContent)) !== null) {
    const schemaPath = match[1]
    const jsonRaw = match[2]
    try {
      const schemaJson = JSON.parse(jsonRaw)
      schemaEntries.push({ schemaPath, schemaJson })
    } catch (error) {
      throw new Error(`Failed to parse JSON schema for ${schemaPath}: ${(error as Error).message}`)
    }
  }
  return schemaEntries
}

async function ensureDirectory(dirPath: string): Promise<void> {
  await fs.mkdir(dirPath, { recursive: true })
}

function needsRewrite(existingContent: string): boolean {
  return existingContent.includes(GENERATED_TAG)
}

function toPascalCase(value: string): string {
  return value
    .replace(/[^a-zA-Z0-9]+/g, ' ')
    .split(' ')
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join('')
}

function toCamelCase(value: string): string {
  const pascal = toPascalCase(value)
  return pascal.charAt(0).toLowerCase() + pascal.slice(1)
}

function schemaConstName(schemaPath: string): string {
  const base = path.basename(schemaPath, '.schema.json')
  return `${toCamelCase(base)}Schema`
}

function typeNameFromSchema(schemaPath: string, schemaJson: JsonSchema): string {
  if (schemaJson.title) {
    return schemaJson.title.replace(/[^a-zA-Z0-9]/g, '')
  }
  const base = path.basename(schemaPath, '.schema.json')
  return toPascalCase(base)
}

function resolveTsType(schema: JsonSchema, depth = 0): string {
  if (!schema) {
    return 'unknown'
  }
  if (Array.isArray(schema.enum) && schema.enum.length > 0) {
    return schema.enum.map((value) => JSON.stringify(value)).join(' | ')
  }

  const schemaType = schema.type
  if (schemaType === 'array' && schema.items) {
    return `${resolveTsType(schema.items, depth + 1)}[]`
  }

  if (schemaType === 'object') {
    const properties = schema.properties ?? {}
    const required = new Set(schema.required ?? [])
    const inner = Object.entries(properties)
      .map(([key, propSchema]) => {
        const optional = !required.has(key)
        const comment = propSchema.description ? ` // ${propSchema.description}` : ''
        return `  ${key}${optional ? '?' : ''}: ${resolveTsType(propSchema, depth + 1)};${comment}`
      })
      .join('\n')
    return `{\n${inner}\n}`
  }

  switch (schemaType) {
    case 'string':
      return 'string'
    case 'integer':
    case 'number':
      return 'number'
    case 'boolean':
      return 'boolean'
    case 'null':
      return 'null'
    default:
      return 'unknown'
  }
}

function buildTsFile(schemaPath: string, schemaJson: JsonSchema): string {
  const typeName = typeNameFromSchema(schemaPath, schemaJson)
  const required = new Set(schemaJson.required ?? [])
  const properties = schemaJson.properties ?? {}
  const tsProps = Object.entries(properties)
    .map(([key, propSchema]) => {
      const optional = !required.has(key)
      const description = propSchema.description ? `  // ${propSchema.description}` : ''
      return `  ${key}${optional ? '?' : ''}: ${resolveTsType(propSchema)};${description}`
    })
    .join('\n')

  const schemaLiteral = JSON.stringify(schemaJson, null, 2)

  return `/**
 * ${GENERATED_TAG}
 * Source: ${path.relative(ROOT_DIR, SPEC_PATH)}
 */
export const ${schemaConstName(schemaPath)} = ${schemaLiteral} as const

export type ${typeName} = {
${tsProps}\n}
`
}

interface PythonEmitContext {
  needsOptional: boolean
  needsList: boolean
  needsDict: boolean
  needsAny: boolean
  needsLiteral: boolean
}

function pythonTypeFromSchema(schema: JsonSchema, isRequired: boolean, ctx: PythonEmitContext): string {
  if (!schema) {
    ctx.needsAny = true
    return isRequired ? 'Any' : 'Optional[Any]'
  }

  const { enum: enumValues } = schema
  if (Array.isArray(enumValues) && enumValues.length > 0) {
    ctx.needsLiteral = true
    const literalValues = enumValues.map((value) => JSON.stringify(value)).join(', ')
    const base = `Literal[${literalValues}]`
    if (isRequired) {
      return base
    }
    ctx.needsOptional = true
    return `Optional[${base}]`
  }

  const schemaType = schema.type
  switch (schemaType) {
    case 'string': {
      const base = 'str'
      if (isRequired) {
        return base
      }
      ctx.needsOptional = true
      return `Optional[${base}]`
    }
    case 'integer': {
      const base = 'int'
      if (isRequired) {
        return base
      }
      ctx.needsOptional = true
      return `Optional[${base}]`
    }
    case 'number': {
      const base = 'float'
      if (isRequired) {
        return base
      }
      ctx.needsOptional = true
      return `Optional[${base}]`
    }
    case 'boolean': {
      const base = 'bool'
      if (isRequired) {
        return base
      }
      ctx.needsOptional = true
      return `Optional[${base}]`
    }
    case 'array': {
      ctx.needsList = true
      const inner = pythonTypeFromSchema(schema.items ?? {}, true, ctx)
      const base = `List[${inner}]`
      if (isRequired) {
        return base
      }
      ctx.needsOptional = true
      return `Optional[${base}]`
    }
    case 'object': {
      ctx.needsDict = true
      ctx.needsAny = true
      const base = 'Dict[str, Any]'
      if (isRequired) {
        return base
      }
      ctx.needsOptional = true
      return `Optional[${base}]`
    }
    default: {
      ctx.needsAny = true
      const base = 'Any'
      if (isRequired) {
        return base
      }
      ctx.needsOptional = true
      return `Optional[${base}]`
    }
  }
}

function buildPythonModel(schemaPath: string, schemaJson: JsonSchema): { code: string; className: string } {
  const className = typeNameFromSchema(schemaPath, schemaJson)
  const ctx: PythonEmitContext = {
    needsOptional: false,
    needsList: false,
    needsDict: false,
    needsAny: false,
    needsLiteral: false,
  }

  const required = new Set(schemaJson.required ?? [])
  const properties = schemaJson.properties ?? {}
  const fieldLines: string[] = []

  for (const [key, propSchema] of Object.entries(properties)) {
    const isRequired = required.has(key)
    const annotatedType = pythonTypeFromSchema(propSchema, isRequired, ctx)
    const fieldDescription = propSchema.description ? `, description="${propSchema.description.replace(/"/g, '\\"')}"` : ''
    const defaultValue = isRequired ? '...' : 'None'
    fieldLines.push(`    ${key}: ${annotatedType} = Field(${defaultValue}${fieldDescription})`)
  }

  const importParts: string[] = []
  const typingImports: string[] = []
  if (ctx.needsOptional) {
    typingImports.push('Optional')
  }
  if (ctx.needsList) {
    typingImports.push('List')
  }
  if (ctx.needsDict) {
    typingImports.push('Dict')
  }
  if (ctx.needsAny) {
    typingImports.push('Any')
  }
  if (ctx.needsLiteral) {
    typingImports.push('Literal')
  }

  if (typingImports.length > 0) {
    importParts.push(`from typing import ${Array.from(new Set(typingImports)).sort().join(', ')}`)
  }

  importParts.push('from pydantic import BaseModel, ConfigDict, Field')

  const docSummary = schemaJson.description ? schemaJson.description : `${className} derived from ${schemaPath}`

  const body = [
    `"""${GENERATED_TAG} -- ${docSummary}."""`,
    'from __future__ import annotations',
    '',
    ...importParts,
    '',
    `class ${className}(BaseModel):`,
    '    """Schema-aligned contract generated from docs/spec.md."""',
    '    model_config = ConfigDict(extra="forbid", populate_by_name=True)',
    '',
    fieldLines.length > 0 ? fieldLines.join('\n') : '    pass',
    '',
  ]

  return {
    code: body.join('\n'),
    className,
  }
}

async function writeFileIfChanged(targetPath: string, newContent: string): Promise<void> {
  const existing = await readFileSafe(targetPath)
  if (existing === newContent) {
    return
  }
  await ensureDirectory(path.dirname(targetPath))
  await fs.writeFile(targetPath, newContent)
}

function buildStubContent(filePath: string, description: string): string {
  const ext = path.extname(filePath)
  const headerComment = `${GENERATED_TAG} -- ${description}`

  if (ext === '.py') {
    return `"""${headerComment}."""\nfrom __future__ import annotations\n\n# TODO: Implement business logic per docs/spec.md\n`
  }

  if (ext === '.tsx' || ext === '.ts') {
    return `/**\n * ${headerComment}.\n * TODO: Implement business logic per docs/spec.md\n */\n`
  }

  return `# ${headerComment}\n# TODO: Implement business logic per docs/spec.md\n`
}

async function scaffoldScopeFiles(scopeEntries: ScopeEntry[]): Promise<void> {
  for (const entry of scopeEntries) {
    const absolutePath = path.join(ROOT_DIR, entry.path)
    const existing = await readFileSafe(absolutePath)
    if (existing) {
      if (needsRewrite(existing)) {
        await fs.writeFile(absolutePath, buildStubContent(entry.path, entry.description))
      }
      continue
    }

    await ensureDirectory(path.dirname(absolutePath))
    await fs.writeFile(absolutePath, buildStubContent(entry.path, entry.description))
  }
}

async function scaffoldSchemas(schemaEntries: SchemaEntry[]): Promise<BackendModelEntry[]> {
  const backendModels: BackendModelEntry[] = []
  for (const { schemaPath, schemaJson } of schemaEntries) {
    const absoluteSchemaPath = path.join(ROOT_DIR, schemaPath)
    await ensureDirectory(path.dirname(absoluteSchemaPath))
    const schemaString = `${JSON.stringify(schemaJson, null, 2)}\n`
    await writeFileIfChanged(absoluteSchemaPath, schemaString)

    const frontendContractsDir = path.join(ROOT_DIR, 'frontend/src/contracts')
    await ensureDirectory(frontendContractsDir)
    const frontendFileName = `${path.basename(schemaPath, '.schema.json')}.ts`
    const frontendPath = path.join(frontendContractsDir, frontendFileName)
    const tsContent = buildTsFile(schemaPath, schemaJson)
    await writeFileIfChanged(frontendPath, tsContent)

    const backendContractsDir = path.join(ROOT_DIR, 'backend/app/contracts')
    await ensureDirectory(backendContractsDir)
    const backendFileName = `${path.basename(schemaPath, '.schema.json')}.py`
    const backendPath = path.join(backendContractsDir, backendFileName)
    const pythonModel = buildPythonModel(schemaPath, schemaJson)
    await writeFileIfChanged(backendPath, `${pythonModel.code}\n`)

    backendModels.push({
      moduleName: path.basename(backendFileName, '.py'),
      className: pythonModel.className,
      filePath: backendPath,
    })
  }
  return backendModels
}

async function updateBackendContractsInit(models: BackendModelEntry[]): Promise<void> {
  if (models.length === 0) {
    return
  }
  const initPath = path.join(ROOT_DIR, 'backend/app/contracts/__init__.py')
  const sorted = models
    .slice()
    .sort((a, b) => a.className.localeCompare(b.className))

  const importLines = sorted.map((model) => `from .${model.moduleName} import ${model.className}`)
  const exports = sorted.map((model) => `    "${model.className}",`)

  const content = `"""${GENERATED_TAG} -- consolidated contract exports."""\nfrom __future__ import annotations\n\n${importLines.join('\n')}\n\n__all__ = [\n${exports.join('\n')}\n]\n`
  await writeFileIfChanged(initPath, content)
}

async function main(): Promise<void> {
  const [specContent, projectRules] = await Promise.all([
    readFileSafe(SPEC_PATH),
    readFileSafe(PROJECT_RULES_PATH),
  ])

  if (!specContent.trim()) {
    throw new Error('docs/spec.md is missing or empty; cannot scaffold')
  }

  if (!projectRules.trim()) {
    console.warn('[WARN] docs/project-rules.md missing; scaffolder will proceed but contracts may drift.')
  }

  const scopeEntries = extractScopeEntries(specContent)
  const schemaEntries = extractSchemaEntries(specContent)

  await scaffoldScopeFiles(scopeEntries)
  const backendModels = await scaffoldSchemas(schemaEntries)
  await updateBackendContractsInit(backendModels)

  console.log(`Scaffolding complete. Processed ${scopeEntries.length} scope entries and ${schemaEntries.length} schemas.`)
}

main().catch((error) => {
  console.error('[ERROR] scaffold.ts failed:', error)
  process.exitCode = 1
})
